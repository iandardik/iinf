\documentclass[runningheads]{llncs}

\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{standalone}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage{skak}
\usepackage{mathtools}
\usepackage{enumerate}
\usepackage[]{soul}

\usepackage{amsmath}
\usepackage{amssymb}

\usepackage{tikz}
\usetikzlibrary{positioning,fit,calc}
\usetikzlibrary{shapes.geometric}

\newcommand{\tla}[1]{{\small\scshape #1}}
\newcommand{\ivy}[1]{{\small\texttt #1}}

\title{CAV 2022 Protocol Conversion}
\author{Ian Dardik}
\date{\today}


\begin{document}

\maketitle


\section{Converting MLDR From TLA+ To Ivy}

Converting the \textit{MongoLoglessDynamicRaft} (MLDR) protocol from TLA+ to Ivy was a nontrivial exercise.  In this appendix we describe the conversion process as well as the challenges we faced.  In this appendix we will refer to EPR as short hand for the broader first order logic fragment \textit{Extended EPR} \cite{padonpaxosEPR}.

\subsection{Protocol Conversion}

The MLDR protocol is introduced in \cite{schultz2021design} along with a TLA+ specification.  We converted the specification to Ivy so we can compare \textit{endive} with other invariant inference tools.  We targeted Ivy $1.8$, the latest version of Ivy to date, during our conversion process.  

The conversion from TLA+ to Ivy can be summarized as a mapping from each component of a TLA+ specification to a component in an Ivy specification.  We show the mapping at a high level in Figure \ref{fig:conv-map}, and provide detail in the sections below.

\begin{figure}
  \begin{center}
  \begin{tabular}{lcl}
    TLA+& & \qquad Ivy $1.8$\\
    \hline
    Sort& $\qquad\to$& \qquad Type\\
    State Variables& $\qquad\to$& \qquad Functions\\
    Initial Constraint Operator& $\qquad\to$& \qquad \ivy{after init}\\
    Transition Relation Operator& $\qquad\to$& \qquad Actions\\
    Auxiliary Operators& $\qquad\to$& \qquad Relations\\
  \end{tabular}
  \end{center}
  \caption{High Level Conversion Mapping}
  \label{fig:conv-map}
\end{figure}

\subsubsection{Sorts And Types}

TLA+ is untyped while Ivy is typed, and thus we need to introduce several types into the new Ivy specification.  The first type is for the sort \textit{Server} that MLDR accepts as a parameter.  The sort is declared in TLA+ using the \tla{constant} keyword, and maps to the \ivy{type} keyword in Ivy.  Second, we include a \ivy{state\_type} type in Ivy to denote primary versus secondary servers.  Third, we introduce a \ivy{nat} type to represent natural numbers, which we equip with total order axioms and the \ivy{succ} operator.  Finally, we include the types \ivy{quorum} and \ivy{conf} to represent quorums and configurations.  While quorums and configurations are conceptually the same type--the power set of \textit{Server}--we found that separating the two types yields a cleaner design in Ivy.

\subsubsection{State Variables}

State variables are encoded in TLA+ using the \tla{variable} keyword, and map to functions and relations in Ivy.  MLDR includes a \textit{TypeOK} property that places constraints on the universe of values for each state variable; we use this property as a direct guide in our state variable conversion, which we show in Figure \ref{fig:statevar-map}.

\begin{figure}
  \begin{align*}
    T&ypeOK ==& \text{I}&\text{vy translation:}\\
      &\land currentTerm \in [Server \to \mathbb{N}]& &\text{function } current\_term(S:server) : nat\\
      &\land state \in [Server \to \{Secondary, Primary\}]& &\text{function } state(S:server) : state\_type\\
      &\land config \in [Server \to \text{SUBSET } Server]& &\text{function } config(S:server) : conf\\
      &\land configVersion \in [Server \to \mathbb{N}]& &\text{function } config\_version(S:server) : nat\\
      &\land configTerm \in [Server \to \mathbb{N}]& &\text{function } config\_term(S:server) : nat\\
  \end{align*}
  \caption{State Variable Conversion Mapping}
  \label{fig:statevar-map}
\end{figure}

\subsubsection{The Initial Constraint And Transition Relation}

The initial constraint is encoded in TLA+ as a conjunction of state variable constraints, and maps to Ivy as a sequence of function constraints, wrapped in an \ivy{after init} block.  The transition relation is encoded in TLA+ as a disjunction of actions, each of which maps to an exported Ivy \ivy{action} block.  Within each action, guards are specified in TLA+ as a constraint on unprimed state variables, and map to the \ivy{assume} keyword in Ivy.  The actions are described symbolically in TLA+ as a relation between unprimed and primed state variables, and map to assignment operators on functions and relations in Ivy (recall that functions and relations represent state variables in Ivy).

\subsubsection{Helper Operators}

In TLA+ it is standard to wrap the initial constraint, transition relation, and each individual action in an operator.  However, operators are also often used as ``helpers" as a means to make a specification modular and readable.  These helper operators directly map to functions and relations in Ivy.

\subsection{Inductive Invariant Conversion}
\label{subsec:indinv-conv}

\textit{Endive} successfully synthesized an inductive invariant for MLDR which we tried to convert from TLA+ to Ivy.  Unfortunately, this inductive invariant introduces a cycle in the quantifier alternation graph of the MLDR Ivy specification, and hence falls outside of EPR \cite{padonpaxosEPR}.  Although techniques exist that may fit a protocol into EPR--such as splitting code with mutually dependent types into modules \cite{McMillan2018DeductiveVI}--these techniques may require significant effort and, in general, are not guaranteed to be complete \cite{padonpaxosEPR}.  Instead of manually using Ivy to find an inductive invariant in EPR, we left this task for the invariant inference tools.

\subsection{Challenges}

During the conversion process we faced two main challenges: fitting MLDR into EPR and validating our newly translated Ivy specification.  We discuss these two challenges below, and incldue a higher level discussion afterward.

\subsubsection{EPR}
\label{sec:mldr-epr}

% EPR & Enough Axioms
% For example, we can't have: axiom ~empty(A) -> quorumof(A, A)

%Fitting MLDR into EPR was especially tough because of the quorum overlap property that must be encoded into MLDR.  They key here is to separate the type for configs and quorums, even though their types are both subsets of \textit{Server}.

Designing MLDR to fit into EPR was not simple, considering that we are newcomers to Ivy.  One of the key hurdles we faced was modeling quorums and configurations without a power set operator; we ultimately converged on using separate types for quorums and configurations which resulted in the quantifier alternation graph \ivy{conf}$\to$\ivy{quorum}$\to$\ivy{server}.  This graph is stratified, and hence fits into EPR.  

\subsubsection{Validating The Translation}

%Once we completed the conversion process, it was not clear how we might test our spec since our inductive invariant puts our spec outside of EPR.  One option would be to develop a new inductive invariant within EPR using Ivy, but this is a costly process and it is not clear whether we are guaranteed to find such an inductive invariant.  Instead we gained intuition by proving simple properties, and by confirming our inductive invariant ``works" in IC3PO for sufficiently large sort sizes.

Once we completed the conversion process, we sought to verify that the Ivy specification was correct.  The ideal test would have been to translate the inductive invariant that \textit{endive} synthesized to prove correctness, yet unfortunately, the inductive invariant places the specification outside of EPR as we noted in section \ref{subsec:indinv-conv}.  Instead, we leveraged IC3PO for our sanity checks.  IC3PO may accept a protocol outside of Ivy's decidable fragment (FAU \cite{Ge2009Complete}), and hence we were able to pass the MLDR Ivy specification along with \textit{endive}'s synthesized inductive invariant.  We performed sanity checks by running IC3PO for several finite instances and confirming that it terminated successfully without adding additional invariants.  This sanity check gave us confidence that our conversion process for MLDR was successful.

\subsubsection{Discussion}

TLA+ is a rather expressive language where we can explicitly create a protocol and model check safety properties to gain confidence.  Ivy, on the other hand, is a more restricted language, and forces protocol designers to write complex code within an individual module in a more implicit fashion.  This implicit fashion entails defining bear bones constructs and providing key axioms--this workflow is aimed at keeping each construct powerful enough to prove key properties, but light enough to remain in the decidable fragment FAU.  For example, consider quorums in the MLDR protocol, whose type is the power set of \textit{Server}.  In TLA+, we can explicitly use a power set operator, making quorums simple to define.  In Ivy, however, there is no support for power sets; instead, a protocol designer can define a binary \textit{member} ${\scriptstyle\subseteq}$ \ivy{server}$\times$\ivy{quorum} relation as a means for providing key axioms that will be necessary for any proofs about quorums.

Ivy's implicit construction workflow begs an important question: how does a protocol designer know when she has provided sufficent axioms in order to prove key theorems on implicitly-defined types?  Presumably, the designer who uses Ivy's interactive workflow will eventually deduce when the set of axioms are insufficient, along with which additional axioms are needed.  Invariant inference tools, however,  provide little to no insight into whether a failure is due to insufficient axioms versus other potential reasons.

Furthermore, it is not clear that a protocol within EPR is guaranteed to have an inductive invariant that is also in EPR.  For any tool that exclusively operates in EPR--or even \textit{works better} in EPR--the tool may experience issues if it is tough, or even impossible, for an inductive invariant to exist in EPR.  In this case, presumably, a designer using Ivy's interactive workflow would eventually discover the need to split the protocol and invariants into modules that avoid quantifier alternation graph cycles, along with exactly how this may be done.  Unfortunately, invariant inference tools offer little to no insight into whether a protocol must be split into modules, and how it may be done.

We do not know the answer to the questions posed above, however, we consider these aspects to be potential limmitations of any tool that operates within EPR or relies on SMT queries in an unbounded domain.  Thus we believe that, to the best of our abilities, we provide a fair comparison for the MLDR protocol between \textit{endive} and any tool that accepts the Ivy version as input.



\bibliographystyle{plain}
\bibliography{refs}

\end{document}
