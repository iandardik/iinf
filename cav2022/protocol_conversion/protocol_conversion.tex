\documentclass[12pt]{article}
\usepackage{anysize}
\marginsize{1.2cm}{1.4cm}{.4cm}{1cm}

\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{hyperref}
\usepackage{amsthm}

\newtheorem{lemma}{Lemma}
\newtheorem{definition}{Definition}

\newcommand{\tla}[1]{{\small\scshape #1}}
\newcommand{\ivy}[1]{{\small\texttt #1}}

\title{CAV 2022 Protocol Conversion}
\author{Ian Dardik}
\date{\today}


\begin{document}

\maketitle


\section{Converting MLDR From TLA+ To Ivy}

Converting the \textit{MongoLoglessDynamicRaft} (MLDR) protocol from TLA+ to Ivy was a nontrivial exercise.  In this appendix we describe the conversion process as well as the challenges we faced.

\subsection{Protocol Conversion}

The MLDR specification is introduced in \cite{schultz2021design} along with a TLA+ specification.  We converted the specification to Ivy so we can compare \textit{endive} with other invariant inference tools.  We targeted Ivy $1.8$, the latest version of Ivy to date, during our conversion process.  

The conversion from TLA+ to Ivy can be summarized as a mapping from each component of a TLA+ specification to a component in an Ivy specification.  We show the mapping at a high level in Figure \ref{fig:conv-map}, and provide detail in the sections below.

\begin{figure}
  \label{fig:conv-map}
  \begin{center}
  \begin{tabular}{lcl}
    TLA+& & Ivy $1.8$\\
    \hline
    Sort& $\to$& Type\\
    State Variables& $\to$& Functions\\
    Initial Constraint Operator& $\to$& \ivy{after init}\\
    Transition Relation Operator& $\to$& Actions\\
    Auxiliary Operators& $\to$& Relations\\
  \end{tabular}
  \end{center}
\end{figure}

\subsubsection{Sorts And Types}

TLA+ is an untyped specification language while Ivy is typed, and thus we need to introduce several types.  The first is for the sort \textit{Server} that MLDR accepts as a parameter.  The sort is declared in TLA+ using the \tla{constant} keyword, and maps to the \ivy{type} keyword in Ivy.  Second, we include a \ivy{state\_type} type in Ivy to denote primary versus secondary servers.  Third, we introduce a \ivy{nat} type to represent natural numbers, which we equip with barebones axioms and operators, including \ivy{succ}.  Finally, we include the types \ivy{quorum} and \ivy{conf} to represent quorums and configurations.  While quorums and configurations are conceptually the same type--the power set of \textit{Server}--we found that separating the two types yields a cleaner design in Ivy.

\subsubsection{State Variables}

State variables are encoded in TLA+ using the \tla{variable} keyword, and map to functions or relations in Ivy.  MLDR includes a \textit{TypeOK} property that places constraints on the universe of values for each state variable; we use this property as a direct guide in our state variable conversion, which we show in Figure \ref{fig:statevar-map}.

\begin{figure}
  \label{fig:statevar-map}
  \begin{align*}
    T&ypeOK ==& \text{I}&\text{vy translation:}\\
      &\land currentTerm \in [Server \to \mathbb{N}]& &\text{function } currentTerm(S:server) : nat\\
      &\land state \in [Server \to \{Secondary, Primary\}]& &\text{function } state(S:server) : state\_type\\
      &\land config \in [Server \to \text{SUBSET } Server]& &\text{function } config(S:server) : conf\\
      &\land configVersion \in [Server \to \mathbb{N}]& &\text{function } config\_version(S:server) : nat\\
      &\land configTerm \in [Server \to \mathbb{N}]& &\text{function } config\_term(S:server) : nat\\
  \end{align*}
\end{figure}

\subsubsection{The Initial Constraint And Transition Relation}

The initial constraint is encoded in TLA+ as a conjunction of individual constraints on state variables, and maps to a sequence of individual constraints in Ivy, wrapped in an \ivy{after init} block.  The transition relation is encoded in TLA+ as a disjunction of individual actions, each of which map to an exported Ivy \ivy{action} block.  Within each action, guards are specified in TLA+ as a constraint on unprimed variables, and map to the \ivy{assume} keyword in Ivy.  The actions themselves are described symbolically in TLA+ as a relation between unprimed and primed state variables, and map to assignment operators on functions and relations in Ivy (recall that functions and relations represent state variables in Ivy).

\subsubsection{Auxiliary Operators}

In TLA+ it is standard to wrap the initial constraint, transition relation, and each individual action in an operator.  However, operators are also often used as ``helpers" as a means to make a specification modular and readable.  We will refer to any such ``helper" operator as an \textit{auxiliary operator}.  Auxiliary operators directly map to functions and relations in Ivy.

\subsection{Inductive Invariant Conversion}

\textit{Endive} successfully synthesized an inductive invariant for MLDR which we tried to convert from TLA+ to Ivy.  Unfortunately, this inductive invariant introduces a cycle in the quantifier alternation graph of the MLDR Ivy specification, and hence falls outside of Extended EPR \cite{padonpaxosEPR}.  Although techniques exist that may fit a protocol into EPR--such as splitting code with mutually dependent types into modules \cite{McMillan2018DeductiveVI}--these techniques may require significant effort and, in general, are not guaranteed to be complete \cite{padonpaxosEPR}.  Instead of manually using Ivy to find an inductive invariant in Extended EPR, we left this task for the automatic synthesis tools.

\subsection{Challenges}

During the conversion process we faced three main challenges which we discuss below.

\subsubsection{EPR}
\label{sec:mldr-epr}

% EPR & Enough Axioms
% For example, we can't have: axiom ~empty(A) -> quorumof(A, A)

%Fitting MLDR into EPR was especially tough because of the quorum overlap property that must be encoded into MLDR.  They key here is to separate the type for configs and quorums, even though their types are both subsets of \textit{Server}.

Designing MLDR to fit into Extended EPR was not clear at first given that we are not experts in this area.  One of the key hurdles we faced was modeling quorums and configurations without a power set operator; we ultimately converged on using separate types for quorums and configurations which led to a clean solution that fit into Extended EPR.

\subsubsection{Validating The Translation}

%Once we completed the conversion process, it was not clear how we might test our spec since our inductive invariant puts our spec outside of EPR.  One option would be to develop a new inductive invariant within EPR using Ivy, but this is a costly process and it is not clear whether we are guaranteed to find such an inductive invariant.  Instead we gained intuition by proving simple properties, and by confirming our inductive invariant ``works" in IC3PO for sufficiently large sort sizes.

Once we completed the conversion process, we sought to verify that the Ivy specification was correct.  The ideal test would have been to encode the inductive invariant that \textit{endive} synthesized to prove correctness, yet unfortunately, the inductive invariant places the specification outside of Extended EPR.  Instead, we leveraged IC3PO for our sanity checks.  IC3PO may accept a protocol outside of FAU, and hence we were able to pass the MLDR Ivy specification along with \textit{endive}'s synthesized inductive invariant.  We performed sanity checks by running IC3PO for several finite instances and confirming that it terminated successfully without adding additional invariants.  This sanity check gave us confidence that our conversion process for MLDR was successful.

\subsubsection{Do Ivy Synthesis Tools Have A Fighting Chance?}

TLA+ is a rather expressive language where we can explicitly create complicated constructs, including second order formulas.  For example, quorums and configurations are key concepts in MLDR, both of whose types are the power set of Server.  In TLA+, the power set--and hence quorums and configurations--can be explicitly defined by using the \tla{subset} keyword.  In Ivy, however, there is no support for power sets or second order logic; instead, a protocol designer can use a binary \textit{member} relation on quorums and configurations to define key axioms that Ivy can use for proving theorems.

The Ivy method--in which we provide key axioms instead of explicitly defining key higher order constructs--begs an interesting question: how do we know that we know that the axioms that we have provided will be sufficient for an automatic invariant synthesis tool to succeed?  When using Ivy to create an inductive invariant by hand, presumably it will be clear that more axioms are needed during the Ivy workflow.  When the task is handed to a synthesis tool, this workflow becomes opaque which implies that insufficient user provided axioms must be added to the long list of possible causes upon failure.
%, rending failure a mystery as to whether the user provided insufficient axioms, 

Furthermore, SWISS and DistAI both operate within EPR, and it may be the case that IC3PO and FOL-IC3 operate more efficiently in EPR.  However, even in the case that a protocol and its key safey property fall into EPR, it is not clear whether an inductive invariant can be synthesized in EPR.  It is possible that \textit{every} possible inductive invariant introduces a quantifier alternation graph cycle, and that the protocol must be split into separate modules as a prerequisite for \textit{any} inductive invariant to possibly be in EPR.  This is also an issue that would presumably be ironed out during manual search for an inductive invariant using the Ivy workflow, and now becomes opaque when handed to an auomatic synthesis tool.
%in order to write down an inductive invariant that fits into EPR alongside the protocol, 


\bibliographystyle{plain}
\bibliography{refs}

\end{document}
