\documentclass[12pt]{article}
\usepackage{anysize}
\marginsize{1.2cm}{1.4cm}{.4cm}{1cm}

\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{hyperref}
\usepackage{amsthm}

\newtheorem{lemma}{Lemma}
\newtheorem{definition}{Definition}

\newcommand{\tla}[1]{{\small\scshape #1}}

\title{CAV 2022 Protocol Conversion}
\author{Ian Dardik}
\date{\today}


\begin{document}

\maketitle



%\section{Introduction}
%Converting the \textit{MongoLoglessDynamicRaft} protocol from TLA+ to Ivy was a nontrivial exercise.  There are two main bottlenecks that we will cover in this note in the sections below.

%The two bottlenecks: quorum overlap property, and staying in EPR (ultimately we just trust IC3PO).

%\section{Conversion}
%Converting the \textit{MongoLoglessDynamicRaft} protocol from TLA+ to Ivy was a nontrivial exercise.  In particular, working within EPR and describing the \textit{Quorum Overlap} property were the two complications we encountered during conversion.  We will begin by describing our solution to these two complications, and then describing the conversion.

%The \textit{MongoLoglessDynamicRaft} protocol relies on the \textit{Quorum Overlap} property to safely move to new server configurations.  The \textit{Quorum Overlap} property is a relation between two confgurations (sets of servers):
%\begin{definition}
  %Given two configurations $c_1, c_2 \in 2^{Server}$, $c_1$ and $c_2$ exhibit the \textit{Quorum Overlap} property iff $\forall Q_1 \in Quorums(c_1), \forall Q_2 \in Quorums(c_2), \exists x \in Server, x \in Q_1 \land x \in Q_2$.
%\end{definition}

%Unfortunately, this statement naturally contains a $\forall\exists$ edge from the set $2^{Server}$ to itself, placing the property outside of Stratified EPR (Padon, et al.).  While techniques such as \textit{information hiding} exist for fitting an Ivy specification into EPR, we found these techniques to be nontrivial and we are still working to fit MLDR into EPR.  To bypass this difficulty, we leveraged the IC3PO tool, which includes a mechanism for checking inductiveness of a property outside of EPR.  Working outside of EPR--and more generally, FAU--allowed us to easily encode a powerset module as well as the Quorum Overlap property.

%Once we encoded the Quorum Overlap property as a relation, the translation from TLA+ to Ivy was straightforward.  



\section{Converting MLDR From TLA+ To Ivy}

%The \textit{MongoLoglessDynamicRaft} protocol was previously implemented in \cite{schultz2021design} as a TLA+ specification.  
Converting the \textit{MongoLoglessDynamicRaft} protocol from TLA+ to Ivy was a nontrivial exercise.  In this appendix we describe the conversion process as well as the challenges we faced.

\subsection{Protocol Conversion}

The \textit{MongoLoglessDynamicRaft} protocol that is introduced in \cite{schultz2021design} is encoded as a TLA+ specification.  The specification encodes the STS using TLA+ constructs; the sort \textit{Server} is encoded as a \tla{constant}, each state variable is encoded as a \tla{variable}, and the initial constraint and transition relation are each encoded as a TLA+ \textit{operator}.  In addition, the TLA+ spec also includes several auxiliary operators that make the spec more readable.  We can convert by mapping the sort \textit{Server} to Ivy's \textit{type} construct, the state variables to Ivy \textit{functions}, the initial constraint and transition relation to Ivy \textit{actions}, and the auxiliary operators to relations.  We describe each mapping in a separate section below, except for the sort \textit{Server} because it maps directly to an Ivy \textit{type}.  We provide a summary of the mapping below:

\begin{center}
\begin{tabular}{lcl}
  TLA+& & Ivy\\
  \hline
  %\tla{constant} Server& $\to$& type server\\
  Sort& $\to$& Type\\
  State Variables& $\to$& Functions\\
  Initial Constraint Operator& $\to$& ``after init" Action\\
  Transition Relation Operator& $\to$& Actions\\
  Auxiliary Operators& $\to$& Relations\\
\end{tabular}
\end{center}

\subsubsection{State Variable Mapping}

TLA+ encodes state variables using the \tla{variable} keyword.  Ivy does not have a designated keyword for declaring state variables; instead we use functions.  Ivy is a typed language so we must assign a type to each function.  TLA+ is not typed, however we do encode a constraint on the universe of values for each state varaible in the \textit{TypeOK} property.  We use this property as guide for implementing each state variable as an Ivy function.

\begin{align*}
  T&ypeOK ==& \text{I}&\text{vy translation:}\\
    &\land currentTerm \in [Server \to \mathbb{N}]& &\text{function } currentTerm(S:server) : nat\\
    &\land state \in [Server \to \{Secondary, Primary\}]& &\text{function } state(S:server) : state\_type\\
    &\land config \in [Server \to \text{SUBSET } Server]& &\text{function } config(S:server) : conf\\
    &\land configVersion \in [Server \to \mathbb{N}]& &\text{function } config\_version(S:server) : nat\\
    &\land configTerm \in [Server \to \mathbb{N}]& &\text{function } config\_term(S:server) : nat\\
\end{align*}

This mapping implies that we also need three more types: \textit{nat}, \textit{state\_type}, and \textit{conf}, which we encode as Ivy types.

\subsubsection{Initial Constraint And Transition Relation Mapping}

The initial constraint is encoded as a conjunction of constraints on the state variables in TLA+.  This remains the same in Ivy; we simply wrap the constraint in a ``after init" action.  The transition relation for MLDR--as is typical in TLA+--is encoded as a disjunction of several individual transitions.  In Ivy, we enumerate each individual transition as an exported action.  Transition guards are described in TLA+ with a constraint on non-primed variables, while guards in Ivy are described using the ``assume" keyword to describe any constraints/preconditions for actions.  Transitions in TLA+ are described symbolically as a relation between unprimed and primed state variables, while transitions in Ivy are described via assignment.  The translations are straightforward.

\subsubsection{Auxiliary Operator Mapping}

Operators in TLA+ can be encoded as relations with definitions.  Give some examples.  In particular, give quorum\_overlap as an example because we will hone in on this in a later section.


\subsection{Inductive Invariant Conversion}

This was straightforward, especially given the auxiliary operators that were previously translated to Ivy.  Unfortunately, our inductive invariant does not fall into Extended EPR.  TODO did we try to put it into EPR at all?


\subsection{Challenges}

In this section we cover the challenges we faced during conversion.

\subsubsection{EPR}

Fitting MLDR into EPR was especially tough because of the quorum overlap property that must be encoded into MLDR.  They key here is to separate the type for configs and quorums, even though their types are both subsets of \textit{Server}.

\subsubsection{Testing Our Ivy Spec}

Once we completed the conversion process, it was not clear how we might test our spec since our inductive invariant puts our spec outside of EPR.  One option would be to develop a new inductive invariant within EPR using Ivy, but this is a costly process and it is not clear whether we are guaranteed to find such an inductive invariant.  Instead we gained intuition by proving simple properties, and by confirming our inductive invariant ``works" in IC3PO for sufficiently large sort sizes.


\bibliographystyle{plain}
\bibliography{refs}

\end{document}
